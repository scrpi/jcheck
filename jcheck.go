// Package jcheck provides content validation for json documents.
package jcheck

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
)

// Checker checks documents against a set of rules and reports results.
type Checker interface {
	// AddRule adds a rule containing a pattern and one or more checks
	AddRule(pattern string, checks ...CheckFunc)

	// Check executes each rule against each node in the json object. Returns a pass
	// or fail result in `ok` and a set of results describing failed checks.
	Check() (results []*Result, ok bool)
}

// JSONChecker checks a json document against a set of rules and reports
// results.
type JSONChecker struct {
	nodes  []*node
	rules  []*rule
	permit bool
}

// NewJSONChecker constructs and returns a new checker for checking a JSON
// document.
func NewJSONChecker(js string, opts ...CheckerOption) (Checker, error) {
	obj := map[string]interface{}{}

	if err := json.Unmarshal([]byte(js), &obj); err != nil {
		return nil, err
	}

	jc := &JSONChecker{
		nodes:  scanNodeMap(nil, "", obj),
		permit: true, // By default we permit all paths
	}

	for _, o := range opts {
		o(jc)
	}

	return jc, nil
}

// AddRule adds a rule containing a pattern and one or more checks
//
// Each check is executed independently once a pattern matches a node in the
// json document. A rule fails if any check contained by that rule fails - they
// are effectively combined as a logical 'OR'. e.g. (if !check1 || !check2 ...)
//
// The pattern syntax is as follows:
//
//  pattern:
//      { term }
//
//  term:
//      '#'     matches any sequence of characters
//      '*'     matches any sequence of non-separator ('.') characters
//      '?'     matches any single non-separator ('.') character
//      c       matches character c
//
//  Note: term must match the entire json node path, not just a substring
//
// Example:
//
// 	{
// 		"array": [1, 2, 3],
//		"object": {
//			"subobject": {
//				"number": 15
//			}
//		}
//	}
//
//	// each element of array is permitted
//	AddRule("array.*", Permitted())
//
//	// each member of object is not permitted
//	AddRule("object.*", NotPermitted())
//
//	// pass - object.subobject.number is greater than 12
//	AddRule("object.subobject.number", NumGTE(12.0))
//
func (j *JSONChecker) AddRule(pattern string, checks ...CheckFunc) {
	if len(checks) == 0 {
		return
	}
	j.rules = append(j.rules, newRule(pattern, checks...))
}

// Check executes each rule against each node in the json object. Returns a pass
// or fail result in `ok` and a set of results describing failed checks.
func (j *JSONChecker) Check() (results []*Result, ok bool) {
	for _, cn := range j.nodes {
		// Iterate through nodes and executed checks in reverse order (child
		// first) so that permitted flags have a chance of propagating upwards
		// through node parents.
		cn.forEachNodeReverse(func(n *node) {
			for _, r := range j.rules {
				results = append(results, r.check(n)...)
			}
			if !j.permit && !n.hasPermitRule {
				results = append(results, &Result{
					Path:    n.path,
					Pass:    false,
					FailMsg: "DefaultNotPermitted: no permit rule",
				})
			}
		})
	}

	if len(results) == 0 {
		ok = true
	}

	return results, ok
}

// CheckerOption configures a JSONChecker at construction
type CheckerOption func(*JSONChecker)

// DefaultPermitted instructs the checker to consider all nodes as permitted.
func DefaultPermitted() CheckerOption {
	return func(jc *JSONChecker) {
		jc.permit = true
	}
}

// DefaultNotPermitted instructs the checker to consider all nodes as not
// permitted.
func DefaultNotPermitted() CheckerOption {
	return func(jc *JSONChecker) {
		jc.permit = false
	}
}

// Result represents a failure result generated by a call to `Check()`
type Result struct {
	Pass    bool
	Path    string
	Pattern string
	FailMsg string
}

func (r Result) String() string {
	pass := "Pass"
	if !r.Pass {
		pass = "Fail"
	}
	return fmt.Sprintf("%s: '%s' pattern:'%s' (%s)", pass, r.Path, r.Pattern, r.FailMsg)
}

func parseNum(str string) (float64, error) {
	v, err := strconv.ParseFloat(str, 64)
	if err == nil {
		return v, nil
	}
	origErr := err

	// strconv failed, check for a suffix
	suffix := str[len(str)-1:]
	str = str[:len(str)-1]

	v, err = strconv.ParseFloat(str, 64)
	if err != nil {
		return 0, err
	}

	// succeeded in parsing float. Now apply suffix.
	switch suffix {
	case "u":
		v = v / (1000 * 1000)
	case "m":
		v = v / (1000)
	case "K":
		v = v * (1000)
	case "M":
		v = v * (1000 * 1000)
	default:
		return 0, origErr
	}

	return v, nil
}

// ---------------- Checkers ----------------

// CheckFunc represents a test for a node
type CheckFunc func(*node) (string, bool)

// NotPermitted fails if a path is matched. Only useful when default policy is
// 'Permitted'
func NotPermitted() CheckFunc {
	return func(n *node) (string, bool) {
		return "NotPermitted", false
	}
}

const permittedFuncMsg = "Permitted"

// Permitted passes if a path is matched. Only useful when default policy is
// 'NotPermitted'
func Permitted() CheckFunc {
	return func(n *node) (string, bool) {
		return permittedFuncMsg, true
	}
}

// isType is a helper function testing whether a pathValue is of a given type
func isType(typ valueType) CheckFunc {
	fname := fmt.Sprintf(
		"Is%s%s",
		strings.ToUpper(typ.String()[0:1]),
		typ.String()[1:],
	)

	return func(n *node) (string, bool) {
		if n.typ != typ {
			return fmt.Sprintf("%s: not type %s", fname, typ.String()), false
		}
		return "", true
	}
}

// IsString fails if the path is not a string type
func IsString() CheckFunc {
	return isType(typeString)
}

// IsNumber fails if the path is not a number type
func IsNumber() CheckFunc {
	return isType(typeNumber)
}

// IsObject fails if the path is not an object type
func IsObject() CheckFunc {
	return isType(typeObject)
}

// IsArray fails if the path is not an array type
func IsArray() CheckFunc {
	return isType(typeArray)
}

// IsTrue fails if the path is not of n.e 'true'
func IsTrue() CheckFunc {
	return isType(typeTrue)
}

// IsFalse fails if the path is not of n.e 'false'
func IsFalse() CheckFunc {
	return isType(typeFalse)
}

// IsBoolean fails if the path is not a boolean type
func IsBoolean() CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeFalse && n.typ != typeTrue {
			return "IsBoolean: not boolean", false
		}
		return "", true
	}
}

// IsNull fails if the path is not a null type
func IsNull() CheckFunc {
	return isType(typeNull)
}

// ArrayLenEquals fails if the path is not an array type with a length matching
// the provided len
func ArrayLenEquals(l int) CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeArray {
			return "ArrayLenEquals: not array type", false
		}
		if n.arrayLen != l {
			return fmt.Sprintf("ArrayLenEquals: len != %d", l), false
		}
		return "", true
	}
}

// ArrayLenLT fails if the path is not an array type with a length less than
// the provided len
func ArrayLenLT(l int) CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeArray {
			return "ArrayLenLT: not array type", false
		}
		if n.arrayLen < l {
			return "", true
		}
		return fmt.Sprintf("ArrayLenLT: not less than %d", l), false
	}
}

// ArrayLenLTE fails if the path is not an array type with a length less or
// equal to than the provided len
func ArrayLenLTE(l int) CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeArray {
			return "ArrayLenLTE: not array type", false
		}
		if n.arrayLen <= l {
			return "", true
		}
		return fmt.Sprintf("ArrayLenLTE: not less than or equal to %d", l), false
	}
}

// ArrayLenGT fails if the path is not an array type with a length greater than
// the provided len
func ArrayLenGT(l int) CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeArray {
			return "ArrayLenGT: not array type", false
		}
		if n.arrayLen > l {
			return "", true
		}
		return fmt.Sprintf("ArrayLenGT: not greater than %d", l), false
	}
}

// ArrayLenGTE fails if the path is not an array type with a length greater than
// or equal to the provided len
func ArrayLenGTE(l int) CheckFunc {
	return func(n *node) (string, bool) {
		if n.typ != typeArray {
			return "ArrayLenGTE: not array type", false
		}
		if n.arrayLen >= l {
			return "", true
		}
		return fmt.Sprintf("ArrayLenGTE: not greater than or equal to %d", l), false
	}
}

// StringEquals tests whether the n.e is equal to the provided string
func StringEquals(str string) CheckFunc {
	return func(n *node) (string, bool) {
		switch n.typ {
		case typeString:
			if str == n.str {
				return "", true
			}
			return fmt.Sprintf("StringEquals: != %q", str), false
		default:
			return "StringEquals: not string type", false
		}
	}
}

// StringHasPrefix tests whether the n.e contains a prefix equal to the
// provided string
func StringHasPrefix(str string) CheckFunc {
	return func(n *node) (string, bool) {
		switch n.typ {
		case typeString:
			if strings.HasPrefix(n.str, str) {
				return "", true
			}
			return fmt.Sprintf("StringHasPrefix: != %q", str), false
		default:
			return "StringHasPrefix: not string type", false
		}
	}
}

// StringHasSuffix tests whether the n.e contains a prefix equal to the
// provided string
func StringHasSuffix(str string) CheckFunc {
	return func(n *node) (string, bool) {
		switch n.typ {
		case typeString:
			if strings.HasSuffix(n.str, str) {
				return "", true
			}
			return fmt.Sprintf("StringHasSuffix: != %q", str), false
		default:
			return "StringHasSuffix: not string type", false
		}
	}
}

// NumEquals tests whether the number n.e equals the provided number
func NumEquals(num float64) CheckFunc {
	return func(n *node) (string, bool) {
		v := n.num
		if n.typ == typeString {
			// Try to parse string as a float
			f, err := parseNum(n.str)
			if err != nil {
				return "NumEquals: not a number", false
			}
			v = f
		} else if n.typ != typeNumber {
			return "NumEquals: not a number", false
		}
		if v == num {
			return "", true
		}
		return fmt.Sprintf("NumEquals: does not equal %v", num), false
	}
}

// NumLT tests whether the n.e is less than the provided number
func NumLT(num float64) CheckFunc {
	return func(n *node) (string, bool) {
		v := n.num
		if n.typ == typeString {
			// Try to parse string as a float
			f, err := parseNum(n.str)
			if err != nil {
				return "NumLT: not a number", false
			}
			v = f
		} else if n.typ != typeNumber {
			return "NumLT: not a number", false
		}
		if v < num {
			return "", true
		}
		return fmt.Sprintf("NumLT: not less than %v", num), false
	}
}

// NumLTE tests whether the n.e is less than or equal to the provided number
func NumLTE(num float64) CheckFunc {
	return func(n *node) (string, bool) {
		v := n.num
		if n.typ == typeString {
			// Try to parse string as a float
			f, err := parseNum(n.str)
			if err != nil {
				return "NumLTE: not a number", false
			}
			v = f
		} else if n.typ != typeNumber {
			return "NumLTE: not a number", false
		}
		if v <= num {
			return "", true
		}
		return fmt.Sprintf("NumLTE: not less than or equal to %v", num), false
	}
}

// NumGT tests whether the n.e is greater than the provided number
func NumGT(num float64) CheckFunc {
	return func(n *node) (string, bool) {
		v := n.num
		if n.typ == typeString {
			// Try to parse string as a float
			f, err := parseNum(n.str)
			if err != nil {
				return "NumGT: not a number", false
			}
			v = f
		} else if n.typ != typeNumber {
			return "NumGT: not a number", false
		}
		if v > num {
			return "", true
		}
		return fmt.Sprintf("NumGT: not greater than %v", num), false
	}
}

// NumGTE tests whether the n.e is greater than or equale to the provided number
func NumGTE(num float64) CheckFunc {
	return func(n *node) (string, bool) {
		v := n.num
		if n.typ == typeString {
			// Try to parse string as a float
			f, err := parseNum(n.str)
			if err != nil {
				return "NumGTE: not a number", false
			}
			v = f
		} else if n.typ != typeNumber {
			return "NumGTE: not a number", false
		}
		if v >= num {
			return "", true
		}
		return fmt.Sprintf("NumGTE: not greater than or equal to %v", num), false
	}
}
